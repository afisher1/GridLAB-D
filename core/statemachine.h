/** $Id$
 	Copyright (C) 2008 Battelle Memorial Institute
	@file statemachine.h
	@addtogroup statemachine Schedule state machine
**/

#ifndef _SFSM_H
#define _SFSM_H

#include "schedule.h"
#include "timestamp.h"
#include "complex.h"

typedef struct s_schedule_fsm SCHEDULE_FSM;
typedef enum {
	MT_ANALOG,		/**< machine output an analog signal */
	MT_PULSED,		/**< machine outputs pulses of fixed area with varying frequency to match value */
	MT_MODULATED,	/**< machine outputs pulses of fixed frequency with varying area to match value */
	MT_QUEUED,		/**< machine accrues values and output pulses of fixed area with varying frequency */
} MACHINETYPE; /** type of machine */
typedef enum {
	MPT_DURATION,	/**< pulses are of fixed duration; power is energy/duration */
	MPT_POWER,		/**< pulses are of fixed power; duration is energy/power */
} MACHINEPULSETYPE; /**< the type of pulses generated by the machine */
struct s_schedule_fsm {
	
	/* machine specification */
	SCHEDULE *schedule;	/**< the schedule driving this machine */
	MACHINETYPE type;	/**< the type of this machine */
	union {
		struct {
			double energy;		/**< the total energy used over the shape */
		} analog;
		struct {
			double energy;		/**< the total energy used over the shape */
			double scalar;		/**< the number of pulses over the shape */
			MACHINEPULSETYPE pulsetype;	/**< the fixed part of the pulse (time or power) */
			double pulsevalue;	/**< the value of the fixed part of the pulse */
		} pulsed;
		struct {
			double energy;		/**< the total energy used over the shape */
			double scalar;		/**< the number of pulses over the shape */
			MACHINEPULSETYPE pulsetype;	/**< the fixed part of the pulse (time or power) */
			double pulsevalue;	/**< the value of the fixed part of the pulse */
		} modulated;
		struct {
			double energy;		/**< the total energy used over the shape */
			double scalar;		/**< the number of pulses over the shape */
			MACHINEPULSETYPE pulsetype;	/**< the fixed part of the pulse (time or power) */
			double pulsevalue;	/**< the value of the fixed part of the pulse */
			double q_on, q_off;	/**< the queue thresholds (in units of 1 pulse) */
		} queued;
	} params;	/**< the machine parameters (depends on #type) */

	/* internal machine parameters */
	double r[2];		/**< the state rates */
	double re[2];		/**< the state rate stdevs */ 
	double d[2];		/**< the state transition thresholds */
	double de[2];		/**< the state transition threshold stdevs */
	complex *v;			/**< reference voltage (if any) */

	/* state variables */
	double q;			/**< the internal state of the machine */
	unsigned int s;		/**< the current state of the machine (0 or 1) */
	TIMESTAMP t0;		/**< time of last update (in seconds since epoch) */
	complex *zip[2][3];	/**< the current zip value */
	complex power;		/**< the total power */
};

SCHEDULE_FSM *schedule_fsm_create(SCHEDULE *s, MACHINETYPE t, ...);
int schedule_fsm_init(SCHEDULE_FSM *m, complex *v, complex *zip0, complex *zip1);
TIMESTAMP schedule_fsm_sync(SCHEDULE_FSM *m, TIMESTAMP t1);

#endif